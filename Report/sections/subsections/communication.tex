\documentclass[../DraftNotes.tex]{subfiles}

\begin{document}

We consider the problem of representing synchronous communications between services in a fog environment. In this setting, a deployment of the application is possible if the nodes hosting two communicating services are actually connected by a physical link which meets some security requirements as, for istance, some constraints on the geographical location of the traversed nodes. \\
In order to effectively represent communicating services, then, we have to represent physical links and to provide a language construct for synchronous communications.
\smallskip
To tackle this problem, we opted for representing physical links as bidirectional. This adds a level of complexity in finding a solution to the routing problem, as we have to solve it on a non-directed, cyclic graph, but it seemed a reasonable representation of a physical network. \\
However, as said, we are representing synchronous communications between services, thus we provide a single language construct \emph{send(Args, Service)} to this end. Furthermore, since synchronous calls can lead to starvation, we assume the instruction to be provided with a timeout, hence having two cases:
\begin{itemize}
	\item the send operation succeeds: then the sent value becomes available to the receiving service;
	\item the send operation fails for exceeding timeout.
\end{itemize}
The possibility of failure is taken into account exploiting probability. The user can provide the probability of timeout exceeding using the \emph{responseTime} predicate (i.e. we assume that a receive operation is always executed by the target service, hence not providing an explicit \emph{receive} construct), which in turn is used inside the \emph{ctx} predicate. If the communication succeeds, then the security context of the receiving service is checked to agree with (i.e. to be higher or equal than) the security level of the received value, otherwise no furhter checks are required. \\
Furhtermore, we want a service to be able to send only values which are in its scope and the receiving service to be able to use the received value. To this end, we define a local environment for each service, which is computed while checking the security context and updated with newly received values if the communication succeeds. Note that, in order to simplify the management of local environments, we assume names to be global, in such a way that we can avoid the problem of introducing a fresh name for each received value. Note also that this implies that, if a service has local access to a value named as a received one, the latter always overwrites the former.

\end{document}